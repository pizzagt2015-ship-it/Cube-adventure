<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Cube Game</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  #menu {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 10;
      text-align: center;
  }
  #menu button {
      padding: 15px 30px;
      font-size: 24px;
      cursor: pointer;
      border: none;
      border-radius: 10px;
      background-color: #00aa00;
      color: white;
      margin-top: 20px;
      transition: transform 0.2s ease, background-color 0.2s ease;
  }
  #menu button:hover {
      transform: scale(1.2);
      background-color: #00ff00;
  }
  #menu h1 { font-size: 48px; margin-bottom: 10px; }
  #controls { font-size: 18px; margin-top: 10px; }
  #controls ul { list-style: none; padding: 0; margin: 0; }
  #controls li { margin: 3px 0; }
</style>
</head>
<body>

<div id="menu">
  <h1>Cube Adventure</h1>
  <div id="controls">
    <p>Controls:</p>
    <ul>
      <li>W: Forward</li>
      <li>S: Backward</li>
      <li>A: Left</li>
      <li>D: Right</li>
      <li>Left/Right Arrow: Turn</li>
      <li>Space: Jump / Double Jump</li>
    </ul>
  </div>
  <button id="startBtn">Start</button>
</div>

<!-- background music -->
<audio id="bgMusic" src="illgals.mp3" autoplay loop></audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
let gameStarted = false;
document.getElementById('startBtn').addEventListener('click', ()=>{
    document.getElementById('menu').style.display = 'none';
    gameStarted = true;
});

// Try to play background music immediately
const bgMusic = document.getElementById("bgMusic");
bgMusic.volume = 0.5;
bgMusic.play().catch(err => {
    console.warn("Autoplay was blocked by the browser. Interaction required.");
});

// --- Scene setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// --- Lights ---
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
light.castShadow = true;
scene.add(light);

const ambient = new THREE.AmbientLight(0x404040, 0.5);
scene.add(ambient);

// --- Ground ---
const groundGeometry = new THREE.PlaneGeometry(200, 200);
const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x006400 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// --- Player ---
const player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshPhongMaterial({ color: 0xff0000 })
);
player.position.y = 0.5;
player.castShadow = true;
scene.add(player);

// --- Camera follow ---
const cameraOffset = new THREE.Vector3(0, 5, -10);
function updateCamera() {
    const offset = cameraOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
    camera.position.copy(player.position).add(offset);
    camera.lookAt(player.position);
}

// --- Controls ---
const keys = { w:false, s:false, a:false, d:false, left:false, right:false, space:false };
document.addEventListener('keydown', e => {
    if(e.key==='w') keys.w=true;
    if(e.key==='s') keys.s=true;
    if(e.key==='a') keys.a=true;
    if(e.key==='d') keys.d=true;
    if(e.key==='ArrowLeft') keys.left=true;
    if(e.key==='ArrowRight') keys.right=true;
    if(e.code==='Space') keys.space=true;
});
document.addEventListener('keyup', e => {
    if(e.key==='w') keys.w=false;
    if(e.key==='s') keys.s=false;
    if(e.key==='a') keys.a=false;
    if(e.key==='d') keys.d=false;
    if(e.key==='ArrowLeft') keys.left=false;
    if(e.key==='ArrowRight') keys.right=false;
    if(e.code==='Space') keys.space=false;
});

// --- Particles ---
const particles = [];
const particleGeometry = new THREE.SphereGeometry(0.05, 6, 6);
function spawnParticles() {
    for(let i=0;i<10;i++){
        const color = Math.random() < 0.5 ? 0xffffff : 0xaaaaaa;
        const material = new THREE.MeshBasicMaterial({color: color});
        const particle = new THREE.Mesh(particleGeometry, material);
        particle.position.copy(player.position);
        particle.position.y += 0.5;
        particle.velocity = new THREE.Vector3(
            (Math.random()-0.5)*0.2,
            Math.random()*0.2 + 0.1,
            (Math.random()-0.5)*0.2
        );
        particle.life = 30;
        scene.add(particle);
        particles.push(particle);
    }
}

// --- Platforms ---
const platforms = [];
function createPlatform(x, y, z, vx=0, vz=0, rangeX=0, rangeZ=0, color=0x8B4513){
    const plat = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), new THREE.MeshPhongMaterial({color: color}));
    plat.position.set(x, y, z);
    plat.castShadow = true;
    plat.receiveShadow = true;
    plat.userData = { vx, vz, startX:x, startZ:z, rangeX, rangeZ };
    scene.add(plat);
    platforms.push(plat);
}
createPlatform(5,1,-5);
createPlatform(-5,2.5,-10);
createPlatform(0,4,-15);
createPlatform(10,3,-5,0.05,0,5,0);
createPlatform(-10,5,-10,0,0.05,0,5);

// --- Gray walls ---
const walls = [];
function createWall(x,y,z){
    const wall = new THREE.Mesh(new THREE.BoxGeometry(1,3,10), new THREE.MeshPhongMaterial({ color:0x808080 }));
    wall.position.set(x,y,z);
    wall.castShadow=true;
    wall.receiveShadow=true;
    scene.add(wall);
    walls.push(wall);
}
createWall(0,1.5,-20);
createWall(10,1.5,-10);
createWall(-10,1.5,-10);

// --- Movement ---
const speed=0.1, turnSpeed=0.05;
let velocityY=0, jumpsLeft=2, standingOn=null;
const gravity=-0.01, jumpStrength=0.25, groundLevel=0.5;

// --- Animation ---
function animate(){
    requestAnimationFrame(animate);
    if(!gameStarted) return;

    platforms.forEach(p=>{
        if(p.userData.vx!==0){ p.position.x += p.userData.vx; if(Math.abs(p.position.x-p.userData.startX)>p.userData.rangeX) p.userData.vx*=-1; }
        if(p.userData.vz!==0){ p.position.z += p.userData.vz; if(Math.abs(p.position.z-p.userData.startZ)>p.userData.rangeZ) p.userData.vz*=-1; }
    });

    if(keys.left) player.rotation.y += turnSpeed;
    if(keys.right) player.rotation.y -= turnSpeed;

    const dir = new THREE.Vector3();
    if(keys.w) dir.z=1;
    if(keys.s) dir.z=-1;
    if(keys.a) dir.x=1;
    if(keys.d) dir.x=-1;
    if(dir.length()>0){ dir.normalize(); dir.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y); player.position.add(dir.multiplyScalar(speed)); }

    if(keys.space && jumpsLeft>0){ velocityY=jumpStrength; if(jumpsLeft===1) spawnParticles(); jumpsLeft--; keys.space=false; }

    velocityY+=gravity;
    player.position.y+=velocityY;

    let onGround=false;
    standingOn=null;

    if(player.position.y<=groundLevel){ player.position.y=groundLevel; velocityY=0; onGround=true; }

    platforms.forEach(p=>{
        const dx=Math.abs(player.position.x-p.position.x);
        const dz=Math.abs(player.position.z-p.position.z);
        const dy=p.position.y+0.25;
        if(dx<2 && dz<2 && player.position.y-0.5<=dy && player.position.y-0.5>=dy-0.5 && velocityY<=0){
            player.position.y=dy+0.5; velocityY=0; onGround=true; standingOn=p;
        }
    });

    walls.forEach(w=>{
        const dx=Math.abs(player.position.x-w.position.x);
        const dz=Math.abs(player.position.z-w.position.z);
        if(dx<0.5+0.5 && dz<5+0.5){
            if(player.position.x<w.position.x) player.position.x=w.position.x-1;
            else player.position.x=w.position.x+1;
        }
    });

    if(onGround) jumpsLeft=2;

    if(standingOn){ player.position.x+=standingOn.userData.vx; player.position.z+=standingOn.userData.vz; }

    for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.position.add(p.velocity);
        p.velocity.y+=gravity*0.5;
        p.life--;
        if(p.life<=0){ scene.remove(p); particles.splice(i,1); }
    }

    updateCamera();
    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
